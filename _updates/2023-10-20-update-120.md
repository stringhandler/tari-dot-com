---
layout: update
tag: Developer Update
date: 2023-10-20
author: stringhandler   
thumbnail: update-background.jpg
title: Comparing Sharding Approaches in Blockchain
subtitle: 
class: subpage
---


There are 3 main approaches to sharding blockchains. Mostly, the difference lies in cross-shard transactions take place.

The 3 approaches are:

1. Parachains (E.g. polkadot, Eth 2)
2. Manual Cross-shard Transactions (E.g. Near Protocol’s Nightshade)
3. Automatic Cross-shard Transactions (E.g Tari, Radix, Chainspace)

## Parachains

In the parachains model, each shard functions as it’s own blockchain. Adding parachains is traditionally a long process because every chain needs a secure set of validators.

 However, this approach comes with a trade-off: while the transactions per second (TPS) within a single chain increase, seamless interaction with assets across different shards becomes challenging. 
 For instance, if you intend to exchange Asset A on shard 1 for Asset B on shard 2, you would need to await the coordination of both shards with a beacon chain to complete the transaction. 
 
In many scenarios, it is more efficient to execute a fully cross-chain atomic swap, akin to the process used in two distinct blockchains. 

Interestingly, this was the original design of Tari’s second layer. Yet, as it became evident that cross-shard transactions would be sluggish, along with the difficulty of ensuring that all validator sets were honest, we made the decision to shift to a Cerberus approach.

## Manual Cross-shard Transactions (Near Protocol’s Nightshade)
Another approach is the one taken by Near Protocol’s Nightshade. In this approach,data is segmented according to user accounts. 
To allow cross-shard transactions, the contract code must be carefully crafted to allow the transaction to be broken into multiple distinct 
pieces that can be separately and asynchronously executed on each shard. 
This puts a lot of responsibility on the developer to code properly and leads to a difficult programming model. 

## Automatic Cross-shard Transactions (Cerberus, Chainspace)
In Cerberus (and also Chainspace), data is distributed randomly over the shards, and cross-shard transactions are expected frequently. All transactions are based on a UTXO model, meaning that data must be destroyed when it is changed, and recreated in a new state. 
Because data can only be created once and destroyed once, double spending is prevented across shards as long as the committees pledge the data to only one transaction. The details of how this works is a little too detailed for now.

When a cross shard transaction occurs, the shards involved group up to do consensus rounds. This process is sometimes called Braiding, but in practice the details can be different. The cross shard consensus rounds are done as part of the local consensus rounds, so the process is not stalled like in other sharding strategies. 

### Cerberus Disadvantages

Without any extra extensions, Cerberus is subject to an attack known as the Single Shard Takeover (SST) problem. In fact, all three sharding approaches are vulnerable to this attack. Each chain has mechanisms to detect and recover from SST. Tari is investigating ways to address this, including checkpointing to the base layer. 

## Example

Let’s take an example of a transaction on all three approaches. Let’s use a swap between Asset A and Asset B, where the data required lives on two different shards. 

For parachains, we’ll ignore the usecase of doing a full crosschain atomic swap since it is possible on all three approaches and also nonsharded blockchains. Instead, depending on the technology, you would need to wait for the data to committed to a checkpoint in the beacon chain before the two shards can complete the transaction.

For Near’s Nightshade design, the contract needs to be coded specifically, and the transaction would be broken into two subtransactions. The first transaction removes the funds in the first shard, and then sends the second subtransaction to the second shard to be processed and included in the blockchain. The subtransactions must be cleverly crafted so that they can be processed in between other changes to the data. 

In Cerberus, shard 1 and shard 2 start the transaction locally and lock the data. They communicate with each other to do a braided consensus round, providing the data and proof they have locked the data to this transaction. When both shard have finished consensus, the data is changed in their local shard database. If there is an error, or if one shard cannot provide proof that they have locked the data, both side abort.
